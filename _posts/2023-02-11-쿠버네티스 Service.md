---
layout: article
title: "[Kubernetes] Service "
subtitle: "쿠버네티스 Service"
date: 2023-02-11 16:05:00 +0900
lastmod: 2023-02-11 20:50:00 +0900
tags: 
  - 리눅스
  - k8s

---

<!--more-->  
윈도우(Windows11)환경의 VirtualBox에 설치한 우분투 서버이미지(20.04 LTS)에서 진행하였습니다. 마스터(1대) 워커노드(2대) 총 3대로 진행하였습니다.<br/>


쿠버네티스 Service<br/>

# Service

동일한 서비스를 제공하는 <b>`Pod 그룹의 단일 진입점`</b> 을 제공한다.<br/>

## Definition
```bash
# Service-Definition

apiVersion: v1
kind: Service
metadata:
  name: webui-svc
spec:
  clusterIP: 10.96.100.100 // 생략가능
  selector:
    app: webui
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

## Type

|종류|설명|
|:---:|:---:|
|ClusterIP|Pod 그룹의 단일 진입점(Virtual IP) 생성|
|NodePort|ClusterIP 가 생성된 후<br/> 모든 Worker Node에 외부에서 접속 가능한 포트가 예약|
|LoadBalancer|AWS, GCP, 오픈스택 클라우드에 적용|
|ExternalName|클러스터 안에서 외부에 접속 시 사용할 도메인을 등록해서 사용<br/>클러스터 도메인이 실제 외부 도메인으로 치환되어 동작|


## ClusterIP
- selector의 label이 동일한 파드들의 그룹으로 묶어 단일 진입점(Virtual_IP)를 생성<br/>
- 클러스터 내부에서만 사용가능<br/>
- type 생략 시 default 값으로 10.96.0.0/12 범위에서 할당됨<br/>

```bash
# nginx-cluster.yaml

apiVersion: v1
kind: Service
metadata:
  name: clusterip-service
spec:
  type: ClusterIP
  clusterIP: 10.100.100.100
  selector:
    app: webui
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

Deploy yaml 파일을 생성합니다.<br/>

### 단일 진입점 생성하기

app=webui label을 기준으로 클러스터를 구성해주는 파일(nginx-cluster.yaml) 을 실행한다.<br/>

```bash
kubectl create -f nginx-cluster.yaml
```

cluster 생성을 확인해보자<br/>

```bash
kubectl get svc
kubectl describe svc
```

IP와 EndPoints 를 확인할 수 있고 `curl 10.100.100.100` 요청을 보내면 연결된 3개의 EndPoints에 분산해서 접속한다.<br/>

동일한 화면이 나오기 때문에 추가 설정을 통해 확인해보았다.<br/>

다음 명령어로 컨테이너에 접속해 html을 수정해줬다.

```bash
# 3개의 컨테이너에 모두 실행해준다.

kubectl exec [container name] -it /bin/bash
echo "webui 1" > /usr/share/nginx/html/index.html
exit
```

`curl 10.100.100.100` 명령어로 확인하면 webui 1~3 이 번갈아 나오는 것을 확인할 수 있다.<br/>

라운드 로빈 방식이 아니라 랜덤방식 이기 때문에 특정 컨테이너가 연속해서 여려번 접속하거나 아예 접속하지 않는 경우가 생길 수 있다.<br/>


## NodePort
- 모든 노드를 대상으로 외부 접속 가능한 포트를 예약<br/>
- Default NodePort 범위: 30000 ~ 32767<br/>
- ClusterIP를 생성 후 NodePort를 예약<br/>

```bash
# nginx-nodeport.yaml

apiVersion: v1
kind: Service
metadata:
  name: nodeport-service
spec:
  type: NodePort
  clusterIP: 10.100.100.200
  selector:
    app: webui
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    nodePort: 30200
```

```bash
kubectl create -f nginx-nodeport.yaml
kubectl get svc
```

`curl [node1~3 IP]:30200` 요청을 보내면 아까 설정한 index.html 페이지가 나오는 것을 확인 할 수 있다.<br/>

## LoadBalancer
- Public Cloud(AWS, Azure, GCP 등) 에서 운영가능<br/>
- LoadBalancer를 자동으로 구성 요청<br/>
- NodePort를 예약 후 해당 NodePort로 외부 접근을 허용<br/>

```bash
# nginx-loadbalancer.yaml

apiVersion: v1
kind: Service
metadata:
  name: loadbalancer-service
spec:
  type: LoadBalancer
  selector:
    app: webui
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

```bash
# master node

kubectl delete svc --all
kubectl create -f nginx-loadbalancer.yaml
kubectl get svc
```

## ExternalName

- 클러스터 내부에서 External(외부)의 도메인을 설정<br/>
- DNS 서비스를 제공<br/>

```bash
# external.yaml

apiVersion: v1
kind: Service
metadata:
  name: externalName-svc
spec:
  type: ExternalName
  externalName: google.com // 내가 사용할 도메인 등록
```

```bash
kubectl create -f external.yaml
kubectl get svc
```

테스트용 파드를 생성 해 줍니다.<br/>

```bash
kubectl run externalpod -it --image=centos:7 
curl externalname-svc.default.svc.cluster.local
```

curl 명령어를 사용하면 설정한(externalName) 구글 페이지가 나오는 것을 확인 할 수 있다.<br/>

```bash
kubectl delete --all
```

<br/>
<br/>

# Reference

